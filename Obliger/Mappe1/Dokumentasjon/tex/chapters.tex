\chapter{Introduksjon}


\section{Om applikasjonen}
\begin{itemize}
\item All kode i applikasjonen er på engelsk med hensikt til at denne skal eventuelt kompileres på forskjellige miljøer med ulike typer \"encoding\". 
\item Kompilert med SDK versjon 23: Android 6.0 Marchmallow, Build tools: 23.0.0
\item Mål SDK: API 21: Android 5.0 (Lollipop) Minimal SDK: API 19: Android 4.4 (KitKat)
\item ID for applikasjonen: com.example.s198569.hangman
\item Utviklingsmiljø: Android Tools 1.3.2, Fedora Linux 22 x64
\item Debugging og testing gjennomført på LGE Optimus 2X (P990) med Cyanogenmod Android 4.4.4. Enheten har samme skjermstørrelse som målenhet Samsung Nexus S.
\item Applikasjonen er også testet og debugget på en emulator med Nesus S og API 19.
\end{itemize}


\section{Hva har jeg lært meg?}
Jeg har aldri før utviklet for Android derfor er alle komponenter som jeg bruker i applikasjonen nye for meg. Jeg hatt som mål å strekke meg noe utøver de krav som er beskrevet i oppgavebeskrivelsen. Følgende liste er et sammendrag over de komponenter som er implementert i applikasjonen utøver de som vært introdusert i forelesningene:

\begin{description}

\item[SQLite] Lagring og lesing av data i applikasjonens interne \texttt{SQLite} database.

\item[Styles] Egne stiler for flere komponenter. Eksempel på dette er egne stiler som er brukt i f.eks. \texttt{GamePlayActivity} der det er opprettet egne stiler både for knapper og \texttt{EditText} som benyttes til å vise ord som skal gjettes.

\item[Native preferances] Bruk av \texttt{PreferanceActivity} for å vise innstillinger for applikasjonen på en oversiktlig og ryddig måte. 

\item[Dynamiske komponenter] Opprette grafiske komponenter på en dynamisk måte. Eksempel på dette er tastatur som blir satt opp avhengig av det språk som er valgt for systemet eller applikasjonen (tastaturet blir satt opp fra et predefinert xml fil som inneholder alle bokstaver fra det språket). Alt dette skjer i samme aktivitet, det brukes ingen hardkoding av aktiviteter.

\item[Endring av språk fra app] Endre språk i applikasjonen uten at språk for systemet blitt endret. Det valgte språket blir også bevart dersom applikasjonen roteres. 

\item[Animasjoner] På hovedaktiviteten vises det en animasjon av en «Hangman» som er opprettet manuelt i xml resurser (se \texttt{res $\rightarrow$ anim}). Det er også brukt xml animasjoner på logo slik at den blir vist sakte fra gjennomsiktig bakgrunn (\textit{fade}).

\end{description}



\chapter{Bruksanvisning og aktiviteter}
I følgende kapittel beskrives det hvordan det er tenkt at spillet skal brukes samt en enkel navigasjon mellom applikasjonens skjermbilder. 

\section{Oppstart av applikasjonen}
Når applikasjonen startes blir brukeren presentert av skjermbilde presentert i figur \ref{fig:activity_front}. 
\begin{figure}[ht]
\centering
 \includegraphics[scale=0.25]{./img/bruksanvisning/1.png}
 \caption{Startskjerm for Hangman}
 \label{fig:activity_front}
\end{figure}

Fra dette bilde er det mulig for spilleren å: 
\begin{description}
\item[Play Game] Starte nytt spill. Dette vil ta spilleren til neste skjermbilde der det er mulig å registrere en ny spiller eller velge allerede eksisterende spillere som er registrert fra før.
\item[View Scores] Se på en sammenstilling av poeng for registrerte spillere. Sammenstillingen er sortert etter total poengsum synkende.
\item[Settings] Innstillinger for appen som valg av språk og lyd på eller av (lydeffekter er ikke implementert ennå).
\item[Help] Skjermbilde med regler for applikasjonen informasjon om applikasjonen. 
\item[Quit] Avlutter applikasjonen. 
\end{description}


\section{Nytt spill}

Spilleren blir presentert med et skjermbilde for å starte nytt spill , figur \ref{fig:registrering}. Her er det mulig å starte et nytt spill gjennom å registrere en ny spiller eller fortsette som en spiller som allerede er registrert fra tidligere. Figur \ref{fig:ny_spiller} viser tilnærming for registrering av en ny spiller. Her blir brukeren varslet om at et nytt brukernavn er registrert via en \texttt{toast} og spurt dersom man ønsker å fortsette å spille med den nye spilleren. Spillet starter og et nytt brukernavn er presenter på spille aktiviteten i nord-vestre hjørne , figur \ref{fig:spill_igang}.

\begin{figure}[ht]
    \centering
    \begin{subfigure}[b]{0.25\textwidth}
        \includegraphics[width=\textwidth]{./img/bruksanvisning/2.png}
        \caption{Registrering}
        \label{fig:registrering}
    \end{subfigure}
    \begin{subfigure}[b]{0.25\textwidth}
        \includegraphics[width=\textwidth]{./img/bruksanvisning/3.png}
        \caption{Ny spiller registrert}
        \label{fig:ny_spiller}
    \end{subfigure}
    \begin{subfigure}[b]{0.25\textwidth}
        \includegraphics[width=\textwidth]{./img/bruksanvisning/4.png}
        \caption{Pågående spill}
        \label{fig:spill_igang}
    \end{subfigure}
    \caption{Nytt spill med en ny spiller}\label{fig:new_game_activities}
\end{figure}

Etter et spilleren har gjettet alle ord og vunnet eller ha mislykket med å avsløre hvilket ord som skjer seg bak firkantene blir spilleren spurt om man ønsker å spille én gang til, figur \ref{fig:fortsette}. Dersom det svares ja startes et nytt spill i samme økt. Dersom man har spilt minst et spill i økten blir spilleren presentert med enkel statistikk for den pågående økten i nord-østlig hjørne, se figur \ref{fig:nyt_spill_samme_okt}. I statistikken presenteres: (1) aktuelt antall poeng, (2) totalt antall poeng som spilleren har tjent sammen i pågående økt, (3) antall spill som er vunnet i økten samt (4) antall spill som er tapt. 

\begin{figure}[ht]
    \centering
    \begin{subfigure}[b]{0.25\textwidth}
        \includegraphics[width=\textwidth]{./img/bruksanvisning/5.png}
        \caption{Fortsette?}
        \label{fig:fortsette}
    \end{subfigure}
    \begin{subfigure}[b]{0.25\textwidth}
        \includegraphics[width=\textwidth]{./img/bruksanvisning/6.png}
        \caption{Nytt spill}
        \label{fig:nyt_spill_samme_okt}
    \end{subfigure}
    \caption{Nytt spill i samme økt}\label{fig:new_game_activities}
\end{figure}


\section{Innstillinger}
I oppgaven skal det implementeres mulighet til endring av språk i applikasjonen uten en endring av systeminnstillinger. For å implementere slik funksjonalitet er det brukt \texttt{PreferenceActivity} som tillater en ryddig oppsamling av alle innstillinger som skal brukes i applikasjonen. Aktivitet med innstillinger startes har hoved menyen med \texttt{Settings} hvilken deretter starter aktivitet som presenteres i figur \ref{fig:innstllinger_oversikt}. Her blir det presentert en liste med alle mulige innstillinger i applikasjonen (anm. innstilling av skru på og av lyd er foreløpig ikke implementert ettersom det er ingen lydeffekter som er implementert i den versjonen). 

Brukeren har dog mulighet å endre språk for hele applikasjonen og blir presentert med en liste av alle aktuelt tilgjengelige språk, figur \ref{fig:innstllinger_velg_sprak}. Dersom brukeren velger et annet språk enn hva som er aktivt blir det presentert en kort advarsel om at dette er en \textit{alpha} funksjonalitet, figur \ref{fig:innstillinger_advarsel}. 

Jeg har valgt å varsle brukeren om dette ettersom det er en ikke anbefalt måte å endre språk på i en kjørende applikasjon. Det er noe som skal helt gjøres fra systemets språkinnstillinger ettersom Android systemet er satt opp på en måte som forsøker starte alle nye aktiviteter i det språk som er aktivt i systemet. Dette danner noen utfordringer under blant annet rotasjon av skjermen da det må lages spesiell kode i hver aktivitet som tar høyde for at applikasjonen kommer til å forsøke å overgå til standardspråk etter at orienteringen er endret.


\begin{figure}[ht]
    \centering
    \begin{subfigure}[b]{0.25\textwidth}
        \includegraphics[width=\textwidth]{./img/bruksanvisning/7.png}
        \caption{Oversikt}
        \label{fig:innstllinger_oversikt}
    \end{subfigure}
    \begin{subfigure}[b]{0.25\textwidth}
        \includegraphics[width=\textwidth]{./img/bruksanvisning/8.png}
        \caption{Valg av språk}
        \label{fig:innstllinger_velg_sprak}
    \end{subfigure}
    \begin{subfigure}[b]{0.25\textwidth}
        \includegraphics[width=\textwidth]{./img/bruksanvisning/9.png}
        \caption{Advarsel}
        \label{fig:innstillinger_advarsel}
    \end{subfigure}
    \caption{Innstillinger}\label{fig:innstillinger}
\end{figure}

Etter at språk blir endret blir aktiviteten med innstillinger lukket og fokus flyttes automatisk til hovedaktiviteten der alle grafiske komponenter blir opprettet på nytt med et nytt språk. Språkendringen gjelder også spillaktivitet der det dynamisk blir opprettet nytt tastatur med spesifikke tegn for språket (dersom nødvendig) og ordlisten i spillet blir skiftet ut slik at spillet kan tas på det språk som brukeren har valgt, figur \ref{fig:spill_norsk}. Konfigurasjon for tastatur er lagret i \texttt{res $\rightarrow$ values $\rightarrow$ alphabet.xml}.

\begin{figure}[ht]
    \centering
   \begin{subfigure}[b]{0.25\textwidth}
        \includegraphics[width=\textwidth]{./img/bruksanvisning/10.png}
        \caption{Språk endret}
        \label{fig:innstillinger_endret}
    \end{subfigure}
    \begin{subfigure}[b]{0.25\textwidth}
        \includegraphics[width=\textwidth]{./img/bruksanvisning/11.png}
        \caption{Nytt språk i spillet}
        \label{fig:spill_norsk}
    \end{subfigure}
    \caption{Språkinnstillinger endret}\label{fig:innstillinger_endret_norsk}
\end{figure}



\section{Øvrige aktiviteter}
De øvrige aktiviteter som er implementert er (1) aktivitet for oversikt over poeng sammenstilling for alle registrerte spillere og (2) en aktivitet som viser hjelp og regler for spillet. Aktivitet for «High Score» viser alle registrerte spillere og sorterer resultat synkende fra de brukere som har høgste score i spillet, figur \ref{fig:aktivitet_score}. Aktivitet for «Hjelp» er satt opp av vanlig \texttt{TextView} og i tillegg tekst som vises blir formatert med hjelp av html tagger, figur \ref{fig:aktivitet_hjelp}. Begge aktivitetene blir endret hvis brukeren bytter språk i applikasjonen eller i systemet. 

\begin{figure}[ht]
    \centering
   \begin{subfigure}[b]{0.25\textwidth}
        \includegraphics[width=\textwidth]{./img/bruksanvisning/12.png}
        \caption{High score}
        \label{fig:aktivitet_score}
    \end{subfigure}
    \begin{subfigure}[b]{0.25\textwidth}
        \includegraphics[width=\textwidth]{./img/bruksanvisning/13.png}
        \caption{Hjelp}
        \label{fig:aktivitet_hjelp}
    \end{subfigure}
    \caption{Øvrige aktiviteter}\label{fig:aktiviteter_ovrige}
\end{figure}



\chapter{Klasser og struktur}

\emph{I følgende avsnitt presenteres en oversikt over alle klasser i applikasjonen. Dette blir presentert i både listen under med kort beskrivelse og forklaring for hver klasse, samt et uml klassediagram i figur \ref{fig:klassediagram}, side \pageref{fig:klassediagram}.}
\\

\begin{description}
\item[\underline{\texttt{StartGameActivity}}] Klasse som har ansvar for å starte hovedaktiviteten i applikasjonen. 

\begin{description}

\item[\texttt{LoginActivity}]
Denne klassen sørger for å opprette nye brukere eller å logge på eksisterende brukeres som allerede er registrert i spiller. Klassen har en leseforbindelse med databasen. 

\item[\texttt{GamePlayActivity}]
Dette er den største klassen i applikasjonen. Klassen sørger for å opprette en ny økt med spill og kjøre kontinuerlige spillomganger frem til brukeren velger å avslutte eller at ordene tar slutt.

\item[\texttt{HangmanPreferencesActivity}]
Klassen brukes til å starte aktiviteten til innstillinger for programmet. Klassen inneholder klikklytter til listen av innstillinger samt trigger eventuelle dialoger for å skifte språk som vises til brukeren. Dersom språk blir endret lagres det en flagg i \texttt{SharedPreferences} og hoved aktiviteten startes på nytt. 

\item[\texttt{ScoresActivity}]
Klassen har som oppgave å gjøre en forespørsel til DAO klassen\footnote{\texttt{HangmanDataSource}} med hensikt å hente inn en liste over eksisterende brukere og sortere de synkende etter totalt antall opptjente poeng (\textit{leaderboard}).

\item[\texttt{HelpActivity}]
Klassen viser en statisk tekst over spileregler og noen informasjon om applikasjonen. Teksten hentes fra \texttt{strings.xml} og blir internt formatert med html tagger. 

\end{description}

\item[\underline{\texttt{lib}}] 
Pakke med hjelpeklasser. Her er det samlet alle klasser som brukes i form av hjelpeklasser for applikasjonen. 
\begin{description}

\item[\texttt{HangmanDatabase}]
Klassen instanser \texttt{SQLite} database gjennom å arve klassen \texttt{SQLiteOpenHelper}. Klassen brukes til å opprette tabellen i databasen samt har \textit{override} for alle nødvendige metoder som kreves av klassen som arves.

\item[\texttt{HangmanDataSource}]
Dette er hjelpklassen som instanserer \texttt{HangmanDatabase} og implementerer alle nødvendige metoder som brukes til lesing, skriving og henting og behandling av den data som blir hentet fra databasen. Eksempel på dette er oppdatering av spiller score, henting av alle spillere på tabellform og diverse data om spillerne.

\item[\texttt{WordsProvider}]
Klassen brukes til å hente alle tilgjengelige ord til det språk som er valgt i applikasjonen. Klassen benytter seg av \texttt{Collections} klassen i Java slik at alle ord blir lastet inn fra \texttt{res $\rightarrow$ values $\rightarrow$ arrays.xml}. Klassen bruker internt en \texttt{ArrayList} i hvilken alle ord fra filen blir plasser. Listen blir randomisert for hver ny økt med hjelp av \texttt{Collections.shuffle()} slik at rekkefølgen blir alltid forskjellig. 


\item[\texttt{Player}]
Klassen representerer en abstraksjon av spiller i spillet som brukes for å midlertidig lagre alle nødvendige data om spilleren. \texttt{Player} objekt blir opprettet hver gang det registreres ny spiller eller hentes inn en eksisterende fra databasen. Spiller objektene tas vare på så lenge spilleøkte varer, så snart det avsluttes at spill i samme økt. For hvert nytt spill blir spillerens rad oppdatert i databasen med nye poeng som brukeren har tjent opp i spillet.

\end{description}


\end{description}


\begin{landscape}
\begin{figure}[ht]
\centering
 \includegraphics[width=\hsize]{./uml/classdiagram.png}
 \caption{Klassediagram}
 \label{fig:klassediagram}
\end{figure}

\end{landscape}



\chapter{Presentasjon av løsninger}
\emph{I følgende avsnitt presenteres det kodeeksempel over de viktigste løsninger fra applikasjonens klasser, konfigurasjon bestående av xml filer samt grafiske gui elementer. For innføring i detaljerte løsningen og fremgangsmåter refereres til den innleverte kildekoden.}
\section{Lagring av data}

\subsection{\texttt{HangmanDatabase.java}}
Applikasjonen benytter seg av en SQLite database for å ta vare på navn til spillere og total opptjent poengsum for hver enkel spiller. Det lagres også totalt antall spill som hver bruker har vunnet og tapt. Hvordan tabellen i databasen blir dannet presenteres i kodeeksempel \ref{code:tabell_opp}.

\begin{lstlisting}[language=Java, caption=Script for opprettelse av tabell, label=code:tabell_opp]
 private static final String DATABASE_CREATE =
            "create table " + TABLE_PLAYERS + "(" +
                    COLUMN_ID + " integer primary key autoincrement, " +
                    COLUMN_PNAME + " text not null, " +
                    COLUMN_SCORE + " integer, " +
                    COLUMN_WON + " integer, " +
                    COLUMN_LOST + " integer" +
                    ");";
\end{lstlisting}


\subsection{\texttt{HangmanDataSource.java}}
Klassen inneholder en hjelpemetode \texttt{cursorToPlayer} som tar in parameter cursor og henter inn datafelt som plasseres i spilleobjektet. Kodeeksempel \ref{code:cursor_help}

\begin{lstlisting}[language=Java, caption=Hjelpemetode for plasering av cursor, label=code:cursor_help]
private Player cursorToPlayer(Cursor cursor){
        Player player = new Player();
        player.setName(cursor.getString(1));
        player.setScore(cursor.getInt(2));
        player.setWon(cursor.getInt(3));
        player.setLost(cursor.getInt(4));
        return player;
    }
\end{lstlisting}

I kodeeksempel \ref{code:tabell_ny_spiller} presenteres det kode som sørger for å opprettelse av en ny spiller i tabellen. Etter innsetting i tabellen benyttes det \texttt{insertId} variabel som blir returnert fra insert metoden til databasen. Denne id benyttes deretter for å finne frem til riktig spiller i tabellen, det vil si at den spiller som blir dannet der blir også returnert fra databasen og med hjelp av eksempel \ref{code:cursor_help} blir det dannet et spiller objekt som returneres tilbake. Slik tilnærmingsmåte sørger for at spilleren blir lagt inn i databasen ettersom det benyttes felt som er lagret i databasen og ikke de felt som allerede eksisterer i det aktive objektet.

\begin{lstlisting}[language=Java, caption=Metode for oppretting av en ny spiller i tabellen, label=code:tabell_ny_spiller]
public Player createPlayer(String name){
        ContentValues values = new ContentValues();
        values.put(HangmanDatabase.COLUMN_PNAME, name);
        values.put(HangmanDatabase.COLUMN_SCORE, 0);
        values.put(HangmanDatabase.COLUMN_WON, 0);
        values.put(HangmanDatabase.COLUMN_LOST, 0);

        long insertId = database.insert(HangmanDatabase.TABLE_PLAYERS, null, values);

        if(insertId < 0){
            Log.d("HANGMAN", "Could not insert into table.");
        }else{
            Log.d("HANGMAN", "Insertion into table successful");
        }

        Cursor cursor = database.query(HangmanDatabase.TABLE_PLAYERS,
                allColumns, HangmanDatabase.COLUMN_ID + " = " + insertId, null,
                null, null, null);

        cursor.moveToFirst();
        Player newPlayer = cursorToPlayer(cursor);
        cursor.close();

        return newPlayer;
    }
\end{lstlisting}

For å hente \textit{«High Score»} liste benyttes det kode som er presentert i kodeeksempel \ref{code:tabell_alle_spillere}. I presentert eksempel blir spillere hentet inn til peker og sortert direkte i pekeren etter poengkolonnen. Så lenge det eksisterer data som kan plasseres i pekeren opprettes det nye spiller objekter fra data som finnes i databasen og til slutt returneres det en sortert listen med spiller objekter.

\begin{lstlisting}[language=Java, caption=Innheting av alle spiller og sortering, label=code:tabell_alle_spillere]
public List<Player> getAllPlayers(){
        List<Player> players = new ArrayList<Player>();

        Cursor cursor = database.query(HangmanDatabase.TABLE_PLAYERS, allColumns, null, null, null, null, HangmanDatabase.COLUMN_SCORE + " DESC");
        if(cursor == null ) return null;
        cursor.moveToFirst();

        while(!cursor.isAfterLast()){
            Player player = cursorToPlayer(cursor);
            players.add(player);
            cursor.moveToNext();
        }

        cursor.close();
        return players;
    }
\end{lstlisting}


\section{Internasjonalisering}
I klassen \texttt{HangmanPreferencesActivity.java} blir det endret språk utefra valg til brukeren. Dette blir gjennomført gjennom å oppdatere lokale innstillinger til applikasjonen samt lagret i \texttt{SharedPreferences} hvilket språk som skal benyttes, kodeeksempel \ref{code:bytte_sprak}. Deretter startes hovedaktivitet på nytt for å ta i bruk endringer. Ettersom det blir lagret i felles innstillinger hvilket språk som skal benyttes i applikasjonen er den verdien tilgjengelig for alle aktiviteter. Derfor etter bytte av orientering av skjermen vil applikasjonen blir startet om og systemet kommer til å forsøke å sette samme språk på applikasjonen som det er definiert på systemet. 

\begin{lstlisting}[language=Java, caption=Metode for språkbytte, label=code:bytte_sprak]
    private void changeLanguage(String locale_language) {
        Locale locale = new Locale(locale_language);
        Locale.setDefault(locale);
        Configuration config = new Configuration();
        config.locale = locale;
        getApplicationContext().getResources().updateConfiguration(config, null);

        //Saving the chosen language to open it up inside the main activity
        SharedPreferences.Editor spEdit = prefs.edit();
        spEdit.putString(LANGUAGE, locale_language);
        spEdit.apply();

        //Starting main activity
        StartGameActivity.ENABLE_RESTART = true;
        Intent i = new Intent(this, StartGameActivity.class);
        i.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_SINGLE_TOP);
        startActivity(i);
    }
\end{lstlisting}

Dette forebygges gjennom at kontrollere den verdi som er lagret i felles innstillinger med dem som applikasjonen kjører etter rotasjon av skjerm gjennom:
\begin{lstlisting}[language=Java]
getResources().getConfiguration().locale.getDisplayLanguage() 
\end{lstlisting}
Dersom den lagrede veriden overensstemmer ikke med den aktuelle verdien for språket fremtvinges en omstart av aktiviteten med nytt språk med hjelp av kode i eksempel \ref{code:bytte_sprak_rotasjon}.

\begin{lstlisting}[language=Java, caption=Språkkontroll etter rotasjon, label=code:bytte_sprak_rotasjon]
    public void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        setContentView(R.layout.activity_start_game);

        initilizeGuiComponents();

        Log.w("HANGMAN", "appLocale "+appLocale);
        String currentLocale = getResources().getConfiguration().locale.getDisplayLanguage();
        Log.w("HANGMAN", "currentLocale "+currentLocale);

        if(!appLocale.equals(currentLocale)){
            switch (appLocale){
                case "norsk bokmal":
                    changeLanguage("nb_NO");
                    break;
                case "English":
                    changeLanguage("en_US");
                    break;
                default:
                    changeLanguage("en_US");
                    break;
            }
        }
    }
\end{lstlisting}


Etter at språk er endret endres også alle dynamiske komponenter som f.eks. tastatur som blir opprettet fra lokalisert xml fil hvilken hentes fra \texttt{values/alphabet.xml} samt \texttt{values-nb/alphabet.xml}. Denne filen ligger til grunn den endring som foretas i tastaturet som presenteres i figur \ref{fig:aktiviteter_spill_internasjonalisering}.

\begin{figure}[ht]
    \centering
   \begin{subfigure}[b]{0.25\textwidth}
        \includegraphics[width=\textwidth]{./img/losninger/1.png}
        \caption{Engelsk versjon}
        \label{fig:aktivitet_engelsk}
    \end{subfigure}
    \begin{subfigure}[b]{0.25\textwidth}
        \includegraphics[width=\textwidth]{./img/losninger/2.png}
        \caption{Norsk versjon}
        \label{fig:aktivitet_norsk}
    \end{subfigure}
    \caption{Internasjonalisering av spillaktivitet}
    \label{fig:aktiviteter_spill_internasjonalisering}
\end{figure}



\section{GUI komponenter}

Det er ingen applikasjon som kan blir riktig fremgangsrik på kun god funksjonalitet. Det er utrolig viktig med god GUI som ikke er fremtrengende med er bra nok for å gjøre jobben sin. Jeg har ingen direkte erfaring i UX-design men har gjort flere forsøk for å gjøre applikasjonen å «poppe» opp fra mengden og være litt unik. Følgende avsnitt beskriver de tiltak og forsøk som ligger til grunn for design og valg som er tatt.

\subsection{Fargetema} \label{sub:farger}
Fargetema som er valgt til applikasjonen er basert på \texttt{triad} fargebase\footnote{En basefarge og to farger som ligger på her side om complementfargen til basefargen}. Valg av farger er gjort med hjelp av webtjeneste \textit{Paletton} og den originale fargevalget er lagret under følgende \href{http://paletton.com/#uid=3470u0krausgVEBm0wFuzpjybk1}{link}.

\begin{figure}[ht]
\centering
 \includegraphics[scale=0.25]{./img/gui/4.png}
 \caption{Fargevalg baser på \textit{Triad} fargepalett.}
 \label{fig:gui_colors}
\end{figure}


Det valgte fargetemaet bruke i flere tonevariasjoner utover alle komponentene i applikasjonen. De hex koder som er valgt for variasjonene er lagret i \texttt{colors.xml} og presentert i eksempel \ref{xml:colors}.

\begin{lstlisting}[language=XML, caption=Fargepalett i colors.xml, label=xml:colors]
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <color name="primary_0">#3D2CA8</color>
    <color name="primary_1">#796CC8</color>
    <color name="primary_2">#5648B2</color>
    <color name="primary_3">#28188C</color>
    <color name="primary_4">#1B0D6F</color>

    <color name="secondary_1_0">#F3EA25</color>
    <color name="secondary_1_1">#FFF978</color>
    <color name="secondary_1_2">#FFF750</color>
    <color name="secondary_1_3">#CAC109</color>
    <color name="secondary_1_4">#A09900</color>

    <color name="secondary_2_0">#F3A525</color>
    <color name="secondary_2_1">#FFCC78</color>
    <color name="secondary_2_2">#FFBD50</color>
    <color name="secondary_2_3">#CA8109</color>
    <color name="secondary_2_4">#A06400</color>

</resources>
\end{lstlisting}






\subsection{Custom stiler}
De brukes noen komponenter som er opprettet med hjelp av egendefinerte stiler. Eksempel på dette er bokser der alle bokstaver vises og alle knapper som benyttes i applikasjonen. Figur \ref{fig:gui_bokser} viser eksempel på hvordan det er mulig å endre en standard \texttt{TextEdit} slik at den likner på en boks med riktig forgrunn- og bakgrunnsfarge.

\begin{figure}[ht]
    \centering
   \begin{subfigure}[b]{0.3\textwidth}
        \includegraphics[width=\textwidth]{./img/gui/2.png}
        \caption{Bokser lagd av \texttt{EditText}}
        \label{fig:gui_bokser}
    \end{subfigure}
    \begin{subfigure}[b]{0.3\textwidth}
        \includegraphics[width=\textwidth]{./img/gui/3.png}
        \caption{Tastatur}
        \label{fig:gui_tastatur_eng}
    \end{subfigure}
    \caption{Internasjonalisering av spillaktivitet}
    \label{fig:custom_gui_comp}
\end{figure}

Det er flere stiler som er redefinert i applikasjonen. Generelle komponenter som ikke er redefinert er det skiftet farge på i \texttt{styles.xml} slik at de motsvarer det som er satt opp i definisjonen for fargetema. Ut utdrag av den konfigurasjonen presenteres i \ref{xml:stil_styles}. Stiler er satt opp med strengen \texttt{Theme.AppCompat.Light.NoActionBar} hvilken fra API 19 fjerner «action bar» i applikasjonen slik at den kan kjøres i helskjerm modus. 

\begin{lstlisting}[language=XML, caption=Deler av \texttt{styles.xml}, label=xml:stil_styles]
    <style name="AppTheme" parent="Theme.AppCompat.Light.NoActionBar">
        <!-- Customize your theme here. -->
        <item name="android:windowBackground">@color/primary_0</item>
        <item name="android:buttonStyle">@style/button</item>
        <item name="colorControlActivated">@color/secondary_2_2</item>
        <item name="android:textColor">@color/secondary_2_2</item>
        <item name="android:textColorPrimary">@color/secondary_2_2</item>
        <item name="android:textColorSecondary">@color/secondary_1_2</item>
        <item name="android:textColorTertiary">@color/secondary_1_2</item>
        <item name="colorAccent">@color/secondary_1_2</item>
    </style>
\end{lstlisting}

\subsubsection*{Bokser for bokstaver}
I eksempel \ref{xml:stil_EditText} vises hvordan komponenter for \texttt{EditText} ble definert. Stilen brukes deretter direkte i koden der det opprettes passende antall komponenter av \texttt{EditText} utefra antall \texttt{char} som finnes i det ordet som ble trukket fra ordlisten i \texttt{arrays.xml}. 
\begin{lstlisting}[language=XML, caption=Stil for \texttt{EditText}, label=xml:stil_EditText]
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle"
    android:thickness="0dp">
    <solid android:color="@color/primary_0" />
    <stroke
        android:width="2dp"
        android:color="@color/secondary_2_2" />
</shape>
\end{lstlisting}

Kodeeksempel \ref{code:stil_EditText} viser hvordan stilen for \texttt{EditText} blir brukt rett i dynamisk oppretting av tekstbokser for det ord som skal gjettes. I metoden \texttt{setWord()} er det tilgjengelig en \texttt{ArrayList} av EditText objekter som skal representere ordet. Ordet blir deretter hentet fra \texttt{wordsProvider.getNextWord()} som vil kontinuerlig forsyne spilleklassen med nye unike ord (så lenge disse er tilgjengelige i arrays.xml). For mulighet til debuggin gblir de nye ordene også vist i LogCat med tag HANGMAN. Deretter i samme eksempel blir det kalt opp metode \texttt{createLettersToGuess()} som generere EditText på skjermen og setter riktig tema på disse objekter.

\begin{lstlisting}[language=Java, caption=Oppretting av dynamisk  \texttt{EditText}, label=code:stil_EditText]
    private void setWord() {
        lettersCount = 0;
        edComponents = new ArrayList<>();
        letters = wordsProvider.getNextWord();
        
        Log.w(getResources().getString(R.string.exception), Arrays.toString(letters)); //Show new word in log view
        if (letters[0] == '0') {
            Toast.makeText(this, getResources().getString(R.string.info_no_more_letters), Toast.LENGTH_SHORT).show();
            Log.w(getResources().getString(R.string.exception), getResources().getString(R.string.info_no_more_letters));
        }

        lettersOriginal = letters.clone();

        createLettersToGuess();
    }
    
    private void createLettersToGuess(){
        for (char c : letters) {
            final EditText et = new EditText(this);
            et.setEnabled(false);
            et.setTextColor(getResources().getColor(R.color.secondary_2_2));
            et.setTypeface(Typeface.MONOSPACE, Typeface.BOLD);
            et.setTextSize(15);
            et.setWidth(53);
            et.setHintTextColor(getResources().getColor(R.color.secondary_2_1));
            et.setBackgroundResource(R.drawable.edit_text_background);

            edComponents.add(et);
            wordsLayout.addView(et);
            lettersCount++;
        }
    }
\end{lstlisting}


\subsubsection*{Knapper og tastatur}
Konfigurasjon av stiler for knapper består av flere definerte stiler som motsvarer hver enkelt tilstand for knappen. I applikasjonen består disse tilstand av \textit{enabled}, \textit{disabled} (etter at bokstaven er brukt) og \textit{pressed} (da knappen er trukket ned). 
Disse tilstand er definert i \texttt{button\_enabled.xml}, \texttt{button\_disabled.xml}, \texttt{button\_pressed.xml} samt \texttt{button\_focused.xml} (brukes ikke).
Disse stiler er deretter linket til button.xml som deretter er brukt for å redefinere standard android knapp i styles.xml.

\begin{lstlisting}[language=XML, caption=Redefinert stil for knapper i styles.xml, label=xml:stil_knapper]
    <style name="button" parent="@android:style/Widget.Button">
        <item name="android:gravity">center_vertical|center_horizontal</item>
        <item name="android:textColor">#FFFFFFFF</item>
        <item name="android:shadowColor">#FF000000</item>
        <item name="android:shadowDx">0</item>
        <item name="android:shadowDy">-1</item>
        <item name="android:shadowRadius">0.2</item>
        <item name="android:textSize">16dip</item>
        <item name="android:textStyle">bold</item>
        <item name="android:background">@drawable/button</item>
        <item name="android:focusable">true</item>
        <item name="android:clickable">true</item>
    </style>
\end{lstlisting}

I eksempel \ref{xml:stil_knapper_link} og \ref{xml:stil_knapper_stil} vises alle stiler er linket sammen samt eksempel over én knappestil for aktiv knapp.


\begin{lstlisting}[language=XML, caption=\texttt{button.xml} konfigurasjon som linker inn alle stiler, label=xml:stil_knapper_link]
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item
        android:state_enabled="false"
        android:drawable="@drawable/button_disabled" />
    <item
        android:state_pressed="true"
        android:state_enabled="true"
        android:drawable="@drawable/button_pressed" />
    <item
        android:state_focused="true"
        android:state_enabled="true"
        android:drawable="@drawable/button_focused" />
    <item
        android:state_enabled="true"
        android:drawable="@drawable/button_enabled" />
</selector>
\end{lstlisting}

\begin{lstlisting}[language=XML, caption=\texttt{button\_enabled.xml} eksempel på en knappestil for aktivert knapp, label=xml:stil_knapper_stil]
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">
    <gradient
        android:angle="90"
        android:centerColor="@color/primary_1"
        android:endColor="@color/primary_0"
        android:startColor="@color/primary_0" />
    <padding
        android:bottom="7dp"
        android:left="7dp"
        android:right="7dp"
        android:top="7dp" />
    <stroke
        android:width="2dip"
        android:color="@color/primary_0" />
    <corners android:radius="8dp" />
</shape>
\end{lstlisting}

\subsection{Animasjoner} \label{sub:animasjoner}
Animasjoner er satt opp med hjelp av xml konfigurasjon, disse blir brukt i samband med at applikasjon starter på første aktiviteten. Det som blir animert er tittelen og hangman figuren som skal gi inntrykk av å bli «hengt» fra overskriften, se figur \ref{fig:hangman_animasjon}.


\begin{figure}[ht]
    \centering
   \begin{subfigure}[b]{0.25\textwidth}
        \includegraphics[width=\textwidth]{./img/gui/a1.png}
    \end{subfigure}
    \begin{subfigure}[b]{0.25\textwidth}
        \includegraphics[width=\textwidth]{./img/gui/a2.png}
    \end{subfigure}
    \begin{subfigure}[b]{0.25\textwidth}
        \includegraphics[width=\textwidth]{./img/gui/a3.png}
    \end{subfigure}
    \caption{Animasjon i start aktivitet}
    \label{fig:hangman_animasjon}
\end{figure}

Overskriften blir animert med én toningseffekt og hangman får en animasjon som skal påminne om en pendel bevegelse fra venstre til høyre så lenge første aktiviteten er aktiv i applikasjonen. Kode for konfigurasjon av disse to animasjoner er splittet i to separate filer onder \texttt{anim} resurser og presenteres i sin helhet i kodeeksempel \ref{xml:animasjoner}.

\begin{lstlisting}[language=XML, caption=Konfigurasjon for samtlige animasjoner i startskjerm, label=xml:animasjoner]
<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android" android:fillAfter="true">
    <alpha
        android:duration="3000"
        android:fromAlpha="0.0"
        android:interpolator="@android:anim/accelerate_interpolator"
        android:toAlpha="1.0" />
    <scale
        android:duration="1000"
        android:interpolator="@android:anim/linear_interpolator"
        android:fromXScale="1.0"
        android:fromYScale="0.0"
        android:toXScale="1.0"
        android:toYScale="1.0" >
    </scale>
</set>

<?xml version="1.0" encoding="utf-8"?>
<set
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:fillAfter="true" >
    <scale
        android:duration="1000"
        android:interpolator="@android:anim/linear_interpolator"
        android:fromXScale="1.0"
        android:fromYScale="-10.0"
        android:toXScale="1.0"
        android:toYScale="1.0" >
    </scale>
    <rotate
        android:fromDegrees="15"
        android:toDegrees="-15"
        android:pivotX="50%"
        android:pivotY="0%"
        android:duration="2000"
        android:repeatMode="reverse"
        android:repeatCount="-1"
        />
</set>
\end{lstlisting}



\subsection{Illustrasjoner}

Under spillets gang hver gang spiller gjetter feil bokstav vil det fremkomme en ny del av hangman figuren. Figuren består av totalt sju bilder som blir skiftet ut i en \texttt{ImageView} komponent. For at illustrasjonen ikke skal bevege seg kommer er den laget i en «lerret» av samme størrelse i alle figurer (opprettet i Inkscape), se figur \ref{fig:hangman_progresjon}.

\begin{figure}[ht]
    \centering
   \begin{subfigure}[b]{0.1\textwidth}
        \includegraphics[width=\textwidth]{./img/gui/hang0.png}
    \end{subfigure}
    \begin{subfigure}[b]{0.1\textwidth}
        \includegraphics[width=\textwidth]{./img/gui/hang1.png}
    \end{subfigure}
    \begin{subfigure}[b]{0.1\textwidth}
        \includegraphics[width=\textwidth]{./img/gui/hang2.png}
    \end{subfigure}
    \begin{subfigure}[b]{0.1\textwidth}
        \includegraphics[width=\textwidth]{./img/gui/hang3.png}
    \end{subfigure}
    \begin{subfigure}[b]{0.1\textwidth}
        \includegraphics[width=\textwidth]{./img/gui/hang4.png}
    \end{subfigure}
    \begin{subfigure}[b]{0.1\textwidth}
        \includegraphics[width=\textwidth]{./img/gui/hang5.png}
    \end{subfigure}
    \begin{subfigure}[b]{0.1\textwidth}
        \includegraphics[width=\textwidth]{./img/gui/hang6.png}
    \end{subfigure}
    \caption{Progresjon av hangman bilde}
    \label{fig:hangman_progresjon}
\end{figure}

\subsection{Designprinsipper fra \texttt{developer.android.com}}

Oppgaveteksten fremfører at man skal spesifisere hvilke designprinsipper som ligger til grunn for applikasjonen som man kan lese om på \href{http://developer.android.com/design/index.html}{developer.android.com}.
Følgende siden viser til mesteparten anbefalinger for \textit{material design} som er det nye grafiske grensesnittet tilgjengelig fra API 21 (Lollipop). Even om i prinsipp detter grensesnittet skal være kompatibelt med v7 bibliotek\footnote{\href{http://developer.android.com/tools/support-library/features.html\#v7-appcompat}{http://developer.android.com/tools/support-library/features.html\#v7-appcompat}} 
er den ikke tatt i bruk i denne applikasjon fordi det jeg ansåg ikke at slik rammeverk er relatert til spill.
Imidlertid er det mulig å relatere noen av de designprinsipper som beskrives på siden direkte til denne appen. Disse er da blant annet: 

\begin{enumerate}
\item \textbf{\textsl{\href{https://www.google.com/design/spec/usability/accessibility.html}{Tilgjengelighet}}}
Fargevalget som er tatt for applikasjonen er testet slik at fargen som brukes vil også fungere for brukere med fargeblindhet. Dette er både gjennomført i nettjenesten\footnote{Dette kan testes gjennom å gå til \href{http://paletton.com/\#uid=3470u0krausgVEBm0wFuzpjybk1}{paletton.com} og velge \textit{color simulation}} som bruktes for å velge farger og direkte på en fysisk enhet. Testene var gjennomført på en Nexus 4 enhet med API 22 som tillater endring av fargerom for å visualisere fargeblindhet. Det er testet for både rød-grønn og blå-gul versjoner av fargeblindhet hvilket i teorien viste at alle komponenter i det brukte fargetemaet er godt synlige. Det var dessverre ikke mulig å ta skjermebild av testen ettersom simulasjonen er en \textit{«overlay»} som legges rett på fysisk ouput til skjerm og ikke på applikasjonsnivå. 

\item \textbf{\textsl{\href{https://www.google.com/design/spec/animation/authentic-motion.html}{Animasjon og transisjoner}}}
Som tidligere beskrevet i avsnitt \ref{sub:animasjoner} benyttes animasjon på startaktiviteten for både overskrift og hangman figur. Det brukes også standard transmisjoner i alle komponenter som representeres av \texttt{ListView} komponenter. Slike komponenter benyttes blant annet meny til på start aktiviteten og for valg av eksisterende spillere. se figur \ref{fig:design_trans}.

\begin{figure}[ht]
    \centering
   \begin{subfigure}[b]{0.25\textwidth}
        \includegraphics[width=\textwidth]{./img/design/d1.png}
    \end{subfigure}
    \begin{subfigure}[b]{0.25\textwidth}
        \includegraphics[width=\textwidth]{./img/design/d2.png}
    \end{subfigure}
    \caption{Eksempel over transmisjoner brukt \texttt{ListView} elementer}
    \label{fig:design_trans}
\end{figure}

\item \textbf{\textsl{Farger}}
Som de anbefales i \href{https://www.google.com/design/spec/style/color.html}{design manualen} skal man benytte seg av flere toner av de farger som brukes. Som tidligere nevnt i avsnitt \ref{sub:farger} er det brukt totalt tre grunnfarger (complement triad farger). Hver enkel av disse farger er deretter «splittet» i flere undertoner i resurser \texttt{colors.xml} og presenteres i eksempel \ref{xml:colors}, side \pageref{xml:colors}. Alle farger som brukes i applikasjonen presenteres også i figur \ref{fig:farger} side \pageref{fig:farger} der fargene er benyttet i forskjellige toningsintervaller i like måte som designguiden. 

\begin{figure}[ht]
\begin{tabularx}{\textwidth}{*6{>{\centering\arraybackslash}X}@{}}

\cellcolor{p0} \emph{primary\_1} & 
\cellcolor{p1} \emph{primary\_2} & 
\cellcolor{p2}\emph{primary\_0} & 
\cellcolor{p3} \emph{primary\_3} & 
\cellcolor{p4} \emph{primary\_4} \\[2ex] 

\cellcolor{s10} \emph{secondary\_1\_1} & 
\cellcolor{s11} \emph{secondary\_1\_2} & 
\cellcolor{s12} \emph{secondary\_1\_0} & 
\cellcolor{s13} \emph{secondary\_1\_3} & 
\cellcolor{s14} \emph{secondary\_1\_4} \\[2ex] 

\cellcolor{s20} \emph{secondary\_2\_1} & 
\cellcolor{s21} \emph{secondary\_2\_2} & 
\cellcolor{s22} \emph{secondary\_2\_0} & 
\cellcolor{s23} \emph{secondary\_2\_3} & 
\cellcolor{s24} \emph{secondary\_2\_4} \\[2ex] 

\end{tabularx} 
\caption[Fargekombinasjoner]{Fargetone som brukes i applikasjonen etter Android designprinsipper. Definert i \texttt{colors.xml}, se kodeeksempel \ref{xml:colors} side \pageref{xml:colors}}
\label{fig:farger}
\end{figure}

\item \textbf{\textsl{\href{https://www.google.com/design/spec/layout/principles.html}{Layout}}}
Ifølge manualen skal applikasjonen være tilpasset til forskjellige skjermstørrelser og ulike pikseldensiteter. Hangman applikasjonen er dessverre kun tilpasset skjermstørrelsen til en Nexus S enhet. På grunn av vanskelighetsnivå kommer det til å legges større vekt på slik tilpassing i etterkommende innleveringer i faget. 
Den generelle layouten som følges i alle aktiviteter i applikasjoner er en sentrert layout som er brukt for stående orientering. Dette er godt synlig på både startskjerm, login aktivitet samt selve spilleaktivitet der både hangmanbilde, tastatur og alle komponenter er orientert rundt en sentral linje. Alle liggende aktiviteter benytter seg av en layout som er orientert mer til høyre side slik at inntasting av bokstaver kan gjøres med høyre hånd.

\item \textbf{\textsl{\href{https://www.google.com/design/spec/components/bottom-sheets.html}{Komponenter}}}
Etter anbefalinger fra manualen er det brukt marginer for alle komponenter slik at disse er plassert på en rimelig avstand fra skjermens kanter og til hverandre. Dette ble oppnådd gjennom at man benyttet seg av relativ layout og grid layout på innsiden av denne. I xml filer der komponentene plasseres ut statisk er de balansert med hjelp av bruk av margin og padding spesifikasjoner. Der det kun benyttes relativ layout brukes de spesifikasjoner at komponentene skal plasseres i forhold til hverandre f.esk. under en spesifikk komponent eller på toppen eller bunn av skjermen. 

\item \textbf{\textsl{\href{https://www.google.com/design/spec/patterns/app-structure.html}{Struktur}}}
Her utgår er det gjort forsøk på at applikasjonen skal være ganske intuitivt å bruker. Fra startskjermen skal det være veldig enkelt for brukeren å navigere seg fre og til bake mellom aktivitetene. Det er ikke brukt noen spesielle komponenter i applikasjonen foruten den navigasjonen som er innebygget i hardware i testenheten Nexus S. I store sammendrag er det brukt den enkleste formen av navigasjon der brukeren kan kun navigere på en linjer måte mellom aktivitetene. Det finnes ingen sidemenyer eller andre komponenter som kan plukkes frem via en menyknapp (slik som material design tilbyr) uten brukeren kan kun navigere frem eller tilbake. Det eneste aktiviteten som bryter detter er dialogen som tillater språkskifte for applikasjonen ettersom ved et språkskifte blir aktiviteten for systeminnstillinger avsluttet og startaktiviteten starter på nytt. 

\end{enumerate} 







\chapter{Utfordringer}
\emph{I dette kapitlet beskrives de utfordringer og ting som er ønskevert til å gjøre bedre.}

\section{Rotasjon og internasjonalisering}
Android rammeverket har et veldig godt støtte for skifting av rotasjon. Dersom det benyttes statiske komponenter som er definert i xml er rotasjon ingen utfordring så lenge man definerer alternative skjermbilder for alternativ layout. Samme tilnærming kan gjøres dersom man skal benytte seg av nytt språk i aktiviteten. Alle komponenter kan da endres enkelt gjennom strings.xml i alternativt språk. Dersom noen komponenter må tilpasses lokalisering f.eks. at teksten skal flyte fra høyre til venstre kan det opprettes alternative skjermbilder for en eller flere språkgrupper. 

I denne oppgave har den første utfordringen gjort seg kjent gjennom at i spillaktiviteten brukes det to dynamiske aktiviteter som ikke er definert i xml kode med blir satt opp og fylt opp direkte fra Java kode. Disse komponenter er boksene med bokstaver og tastatur. Dette designvalget ble tatt for at applikasjonen skulle skalere uavhengig hvilket språk som vil bli benyttet i applikasjonen i fremtiden. For at få et lokalt tilpasset tastatur trenger man in prinsipp legge inn en ny xml fil med lokalt alfabet som heter alphabet.xml (den må i tillegg plasseres i mappe med suffiks som overensstemmer med språket på tastaturet) og velge dette språket i systemet. Det blir automatisk valgt riktig språk og nytt tastatur er opprettet. 

Dynamiske komponenter danner trøbbel så snart man endrer orientering på skjermen. Fordi at disse blir ikke håndtert av rammeverket. Dette kan enkelt løses gjennom å lagre tilstand til disse i en lempelig metode og gjenopprette disse etter at rotasjonen er gjennomført. Et krav for applikasjonen var at brukeren skal kunne skifte språk inne i applikasjonens innstillinger eller meny. Dette blir en utfordring dersom applikasjonen skal klare av følgende bruksmønster:
\begin{enumerate}
\item Brukeren endrer språk i på i applikasjonen, systemspråk forblir uforandret. Vi er nå i en situasjon der systemspråk og og språk i appen er forskjellige. 
\item Brukeren starter et nytt spill og roterer skjermen. 
\item Systemet starter om aktiviteten og kjører \texttt{onCreate(Bundle savedInstanceState)}. Aktiviteten går tilbake til språk som er satt opp på systemet. 
\end{enumerate}

\subsection{Mulig løsning}
Dette er den første løsningen som ble testet uten noen større fremgang eller stabilitet i applikasjonen. 
\begin{enumerate}
\item Etter skifte av språk, lagre det språk som det ble skiftet til i \texttt{SharedPreferences}.
\item Dersom det initialiseres en skjermrotasjon ta vare på alle nødvendige komponenter, objekter og variabler i \texttt{onSaveInstanceState(Bundle outState)} og deretter instansiere de på nytt med hjelp av \texttt{onRestoreInstanceState(Bundle savedInstanceState)}.
\item Etter skjermrotasjon kjører \texttt{onCreate(Bundle savedInstanceState)} applikasjonen skifter språk tilbake til valgt systemspråk. 
\item Det må tvinges frem på nytt et bytte av språk i den kjørende aktiviteten og en omstart av denne for å skifte språk på nytt. Det medfører at applikasjonen kjører \texttt{onCreate()} på nytt og koden går i en evig loop som krever en del ukonvensjonelle løsninger for at får det til å fungere. 
\end{enumerate}

\subsection{Fungerende løsning}
Følgende løsning er det den som er tatt i bruk ettersom den benytter seg av en tilnærmingsmåte som ikke kaller opp \texttt{onCreate(Bundle savedInstanceState)} etter endring av rotasjon. istedenfor blir det benyttet \texttt{onConfigurationChanged(Configuration newConfig)} hvilken er en metode som blir kalt opp i samband med endring i orientering. Metoden medfører følgende tillegg i \texttt{AndroidManifest.xml}:
\begin{lstlisting}[language=XML]
android:configChanges="keyboardHidden|orientation|screenSize"
\end{lstlisting}
Følgende endring i manifestfilen medfører at det ikke lengre blir kalt opp \texttt{onSaveInstanceState} eller \texttt{onRestoreInstanceState} etter en endring rotasjon av skjermen \texttt{onCreate()} kalles kun opp ved første start av aktiviteter. 
I kodeksempel \ref{code:onConfStart} ser vi hvordan det håndteres at spillet etter at brukeren har endret språk i aktiviteten for innstillinger og den aktiviteten har deretter startet hovedaktivitet. Det lagres an delt innstiliingsvariabel som henter inn til hvilket språk som applikasjonen er endret til og deretter etter en rotasjon av skjermen sammenliknes det med at hvilket språk som aktuelt brukes i applikasjonen (se kodelinje 8 og 11). 

\begin{lstlisting}[language=Java, caption=Håndtering av rotasjon i \texttt{StartGameActivity.java}, label=code:onConfStart]
    public void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        setContentView(R.layout.activity_start_game);

        initilizeGuiComponents();

        Log.w("HANGMAN", "appLocale "+appLocale);
        String currentLocale = getResources().getConfiguration().locale.getDisplayLanguage();
        Log.w("HANGMAN", "currentLocale "+currentLocale);

        if(!appLocale.equals(currentLocale)){
            switch (appLocale){
                case "norsk bokmal":
                    changeLanguage("nb_NO");
                    break;
                case "English":
                    changeLanguage("en_US");
                    break;
                default:
                    changeLanguage("en_US");
                    break;
            }
        }
    }
\end{lstlisting}

I kodeeksempel \ref{code:onConfGame} ser vi samme prinsipp men for aktiviteten som brukes til selve spillet. Det benyttes samme prinsipper som i forrige eksempel men i denne aktiviteten benyttes noen dynamiske komponenter som blir som ikke er definert i xml filene. Disse komponenter blir opprettet fra kode og dersom må det til men litt mer sofistikerte metoder for å ta vara på aktuell \textit{«state»} og gjenopprette denne etter at skjermen er rotert. Blant annet må det gjenskapes bokser for bokstavene som man gjetter samt tastatur. Når spillet kjører er det til enhver til også dannet collections av alle \texttt{char} som er vist til brukeren fra ordet samt hvilke taster er det som er brukt opp i tastaturet. Etter at skjermen er rotert blir disse komponenter gjenopprettet fra disse referanser. Etter rotasjon av spillaktiviteten skjer følgende:
\begin{enumerate}
\item Alle GUI objekter hentes inn og castes på nytt i koden (linje 6).
\item Hangman bilde blir gjenopprettet til samme tilstand som før rotasjon (linje 7).
\item Alle statiske GUI komponenter gjenopprettes (linje 10 til 14).
\item Alle dynamiske GUI komponenter gjenopprettes til sin tidligere tilstand (linje 19 til 27).
\end{enumerate}

\begin{lstlisting}[language=Java, caption=Håndtering av rotasjon i \texttt{GamePlayActivity.java}, label=code:onConfGame]
    public void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        setContentView(R.layout.activity_game_play);

        //Re-initializes all components
        initializesGUIComponents();
        updateHangmanImage();

        //Re-populating all stats with saved state data
        playerName.setText(pName);
        gameScoreView.setText(String.valueOf(gameScore));
        sessionScoreView.setText(String.valueOf(sessionScore));
        gamesWonView.setText(String.valueOf(gamesWon));
        gamesLostView.setText(String.valueOf(gamesLost));

        edComponents.clear();
        wordsLayout.removeAllViews();

        createLettersToGuess();

        for (int i = 0; i < lettersOriginal.length; i++) {
            if (letters[i] == 0)
                revealLetter(i, lettersOriginal[i]);
        }
        
        setUpKeyboardAndListen();
        markUsedKeys();
    }
\end{lstlisting}

\section{Arkitektur}
Ettersom det er den første applikasjon for android som jeg lager har jeg ikke lagt fokus på noen spesifikk arkitektur for backend klasser. Dette beslutt ble tatt ettersom jeg utgikk fra at Android rammeverket allerede bruker en klar separasjon mellom grafiske komponenter (xml) og dess logikk (java). Med relativ enkel oppgave for de logiske komponenter som skal håndteres for at slik spill skal fungere burde det i utgangspunktet kunne løses med noen få linjer av kode. Den store utfordringer kom etter at det skal håndteres internasjonalisering med dynamiske gui komponenter og samtidig mulighet til rotasjon av skjermen. Derfor hadde koden blitt betydelig mer oversiktlig dersom man hadde benyttes seg av enkel arv og polymorfi. For eksempel blir tastaturet opprettet fra \texttt{GamePlayActivity.java} og deretter blir det satt lyttere for hver enkel knapp i tastaturet i metoden \texttt{setUpKeyboardAndListen()}. For eksempel det som burde blitt gjort her at man oppretter en egen klasse for alle knapper i hvilken man arver klassen \texttt{Button}. Det vil ikke bare gi tilgang til alle metoder i hovedklassen men også gi mulighet til at man oppretter en lytter for hver instans av en knapp slik at disse kan aksesseres via metoder og kalle opp en \texttt{callback} metode hver gang en knapp blir trukket inn.

For at enklere ta vare på tilstand til selve tastaturet kunde man opprettet en \texttt{wrapper} klasse som holder alle taster. Denne klassen kan da implementere interface som f.eks. \texttt{Pracelable.java} eller \texttt{Sarializable.java} og på den må kunde man lagre hele tilstanden til tastaturet i f.eks. \texttt{onSaveInstanceState} isteden for å benytte seg av \texttt{onConfigurationChanged}. 

Dette er prinsipper som skal tas i stor betraktning for neste innlevering der det skal legges en stor vekt på den underliggende arkitekturen og hvordan alle de komponenter fra rammeverket som skal brukes og dess tilstand skal bevares mellom aktivitetenes livssykluser. 

